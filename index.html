<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>Insane 2D Arcade Shooter with Power-ups & Timer</title>
<style>
  body, html {
    margin: 0; padding: 0; overflow: hidden; background: #111;
    font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
    user-select: none;
  }
  canvas {
    display: block;
    margin: auto;
    background: linear-gradient(135deg, #222 0%, #000 100%);
  }
  #score {
    position: fixed;
    top: 10px; left: 10px;
    color: #0f0;
    font-size: 20px;
    font-weight: bold;
    text-shadow: 0 0 5px #0f0;
  }
  #timer {
    position: fixed;
    top: 10px; right: 10px;
    color: #0ff;
    font-size: 20px;
    font-weight: bold;
    text-shadow: 0 0 5px #0ff;
  }
  #health-bar {
    position: fixed;
    top: 40px; left: 10px;
    width: 200px;
    height: 20px;
    background: #333;
    border: 2px solid #0f0;
    border-radius: 5px;
    overflow: hidden;
  }
  #health-bar-inner {
    height: 100%;
    background: #0f0;
    width: 100%;
    transition: width 0.3s ease;
  }
</style>
</head>
<body>
<div id="score">Score: 0</div>
<div id="timer">Time: 0s</div>
<div id="health-bar"><div id="health-bar-inner"></div></div>
<canvas id="game"></canvas>
<script>
(() => {
  const canvas = document.getElementById('game');
  const ctx = canvas.getContext('2d');
  const W = window.innerWidth;
  const H = window.innerHeight;
  canvas.width = W;
  canvas.height = H;

  let score = 0;
  let gameOver = false;
  let startTime = Date.now();

  // Player object with health
  const player = {
    x: W / 2,
    y: H / 2,
    radius: 20,
    speed: 6,
    color: '#0f0',
    vx: 0,
    vy: 0,
    health: 100,
    maxHealth: 100,
    powerups: {
      speedBoost: 0, // duration frames remaining
      shield: 0,
    }
  };

  const keys = {};
  window.addEventListener('keydown', e => keys[e.key.toLowerCase()] = true);
  window.addEventListener('keyup', e => keys[e.key.toLowerCase()] = false);

  // Bullets array
  const bullets = [];

  // Enemies array
  const enemies = [];

  // Particles array for explosions
  const particles = [];

  // Powerups array
  const powerups = [];

  // Spawn enemies every interval (will get faster)
  let enemySpawnInterval = 1000;
  let lastEnemySpawn = 0;

  // Spawn powerups every interval
  let powerupSpawnInterval = 7000;
  let lastPowerupSpawn = 0;

  // Utility: random number in range
  function randRange(min, max) {
    return Math.random() * (max - min) + min;
  }

  // Player shooting cooldown
  let shootCooldown = 0;

  // Game loop
  function gameLoop(timestamp = 0) {
    if (gameOver) {
      drawGameOver();
      return;
    }
    ctx.clearRect(0, 0, W, H);

    updatePlayer();
    updateBullets();
    updateEnemies(timestamp);
    updateParticles();
    updatePowerups(timestamp);
    drawAll();

    shootCooldown = Math.max(0, shootCooldown - 1);

    updateScore();
    updateHealthBar();
    updateTimer();

    requestAnimationFrame(gameLoop);
  }

  // Update player position and controls
  function updatePlayer() {
    player.vx = 0;
    player.vy = 0;

    // Apply speed boost if powerup active
    const currentSpeed = player.powerups.speedBoost > 0 ? player.speed * 1.5 : player.speed;

    if (keys['w'] || keys['arrowup']) player.vy = -currentSpeed;
    if (keys['s'] || keys['arrowdown']) player.vy = currentSpeed;
    if (keys['a'] || keys['arrowleft']) player.vx = -currentSpeed;
    if (keys['d'] || keys['arrowright']) player.vx = currentSpeed;

    player.x += player.vx;
    player.y += player.vy;

    // Clamp inside screen
    player.x = Math.min(Math.max(player.radius, player.x), W - player.radius);
    player.y = Math.min(Math.max(player.radius, player.y), H - player.radius);

    // Shooting (space or click)
    if ((keys[' '] || keys['enter'] || keys['mouse']) && shootCooldown <= 0) {
      shoot();
      shootCooldown = 10;
    }

    // Decrease powerup timers
    if (player.powerups.speedBoost > 0) player.powerups.speedBoost--;
    if (player.powerups.shield > 0) player.powerups.shield--;
  }

  // Shoot bullet towards mouse position
  let mouseX = W / 2, mouseY = H / 2;
  window.addEventListener('mousemove', e => {
    mouseX = e.clientX;
    mouseY = e.clientY;
  });
  window.addEventListener('mousedown', e => keys['mouse'] = true);
  window.addEventListener('mouseup', e => keys['mouse'] = false);

  function shoot() {
    // Calculate direction vector from player to mouse
    let dx = mouseX - player.x;
    let dy = mouseY - player.y;
    let dist = Math.sqrt(dx*dx + dy*dy);
    dx /= dist;
    dy /= dist;
    bullets.push({
      x: player.x + dx * player.radius,
      y: player.y + dy * player.radius,
      vx: dx * 15,
      vy: dy * 15,
      radius: 5,
      color: '#0ff',
    });
  }

  // Update bullets and remove off-screen
  function updateBullets() {
    for(let i = bullets.length-1; i>=0; i--) {
      const b = bullets[i];
      b.x += b.vx;
      b.y += b.vy;
      if(b.x < 0 || b.x > W || b.y < 0 || b.y > H) {
        bullets.splice(i, 1);
        continue;
      }
      // Check collision with enemies
      for(let j = enemies.length-1; j>=0; j--) {
        const e = enemies[j];
        const dist = Math.hypot(e.x - b.x, e.y - b.y);
        if(dist < e.radius + b.radius) {
          createExplosion(e.x, e.y, e.color);
          enemies.splice(j,1);
          bullets.splice(i,1);
          score += 10;
          break;
        }
      }
    }
  }

  // Spawn enemies & update them
  function updateEnemies(timestamp) {
    if(timestamp - lastEnemySpawn > enemySpawnInterval) {
      spawnEnemy();
      lastEnemySpawn = timestamp;
      // Gradually spawn faster but not too fast
      if(enemySpawnInterval > 400) enemySpawnInterval -= 8;
    }

    for(let i = enemies.length-1; i >= 0; i--) {
      const e = enemies[i];
      // Move towards player
      let dx = player.x - e.x;
      let dy = player.y - e.y;
      let dist = Math.sqrt(dx*dx + dy*dy);
      dx /= dist;
      dy /= dist;

      // Increase enemy speed over time
      e.speed += 0.001;

      e.x += dx * e.speed;
      e.y += dy * e.speed;

      // Check collision with player
      if(dist < e.radius + player.radius) {
        // If shield powerup active, block damage and destroy enemy
        if(player.powerups.shield > 0) {
          createExplosion(e.x, e.y, e.color);
          enemies.splice(i, 1);
          score += 5; // reward a bit for shielded kills
        } else {
          // Damage player & enemy dies
          createExplosion(e.x, e.y, e.color);
          enemies.splice(i, 1);
          player.health -= 15;
          if(player.health <= 0) {
            player.health = 0;
            gameOver = true;
          }
        }
      }
    }
  }

  // Spawn an enemy at random edge with random speed and color
  function spawnEnemy() {
    const side = Math.floor(randRange(0,4)); // 0 top,1 right,2 bottom,3 left
    let x,y;
    if(side === 0) { x = randRange(0,W); y = -30; }
    else if(side === 1) { x = W+30; y = randRange(0,H); }
    else if(side === 2) { x = randRange(0,W); y = H+30; }
    else { x = -30; y = randRange(0,H); }
    const colors = ['#f00','#f80','#ff0','#0f0','#0ff','#08f','#f0f'];
    enemies.push({
      x, y,
      radius: randRange(15,25),
      speed: randRange(1,2),  // start speed lower, will increase gradually
      color: colors[Math.floor(randRange(0,colors.length))],
    });
  }

  // Powerup types:
  // - health: restores 30 health
  // - speed: speed boost for 5 seconds (300 frames)
  // - shield: shield for 5 seconds (300 frames)
  class Powerup {
    constructor(x, y, type){
      this.x = x;
      this.y = y;
      this.radius = 15;
      this.type = type;
      this.color = {
        health: '#f55',
        speed: '#5af',
        shield: '#ff5',
      }[type];
    }
    draw(ctx) {
      ctx.fillStyle = this.color;
      ctx.beginPath();
      ctx.arc(this.x, this.y, this.radius, 0, Math.PI*2);
      ctx.fill();
      ctx.fillStyle = '#000';
      ctx.font = '20px monospace';
      ctx.textAlign = 'center';
      ctx.textBaseline = 'middle';
      const symbol = {
        health: '+',
        speed: 'S',
        shield: 'D'
      }[this.type];
      ctx.fillText(symbol, this.x, this.y + 1);
    }
  }

  // Spawn powerups randomly on the map
  function updatePowerups(timestamp) {
    if(timestamp - lastPowerupSpawn > powerupSpawnInterval) {
      spawnPowerup();
      lastPowerupSpawn = timestamp;
    }

    // Check player collision with powerups
    for(let i = powerups.length-1; i >= 0; i--) {
      const p = powerups[i];
      const dist = Math.hypot(player.x - p.x, player.y - p.y);
      if(dist < player.radius + p.radius) {
        applyPowerup(p.type);
        powerups.splice(i, 1);
      }
    }
  }

  function spawnPowerup() {
    const x = randRange(50, W - 50);
    const y = randRange(50, H - 50);
    const types = ['health','speed','shield'];
    const type = types[Math.floor(randRange(0, types.length))];
    powerups.push(new Powerup(x,y,type));
  }

  function applyPowerup(type) {
    if(type === 'health') {
      player.health = Math.min(player.health + 30, player.maxHealth);
    } else if(type === 'speed') {
      player.powerups.speedBoost = 300; // 5 seconds at 60fps
    } else if(type === 'shield') {
      player.powerups.shield = 300;
    }
  }

  // Particles for explosions
  class Particle {
    constructor(x,y,color){
      this.x = x;
      this.y = y;
      this.vx = randRange(-5,5);
      this.vy = randRange(-5,5);
      this.alpha = 1;
      this.size = randRange(2,5);
      this.color = color;
      this.life = 30;
    }
    update() {
      this.x += this.vx;
      this.y += this.vy;
      this.vy += 0.2; // gravity
      this.alpha -= 1/this.life;
      this.size *= 0.95;
    }
    draw(ctx) {
      ctx.save();
      ctx.globalAlpha = this.alpha;
      ctx.fillStyle = this.color;
      ctx.beginPath();
      ctx.arc(this.x,this.y,this.size,0,Math.PI*2);
      ctx.fill();
      ctx.restore();
    }
  }
  function createExplosion(x,y,color){
    for(let i=0; i<30; i++){
      particles.push(new Particle(x,y,color));
    }
  }
  function updateParticles() {
    for(let i=particles.length-1; i>=0; i--) {
      particles[i].update();
      if(particles[i].alpha <= 0) particles.splice(i,1);
    }
  }

  // Draw all objects
  function drawAll() {
    // Player
    ctx.fillStyle = player.color;
    ctx.beginPath();
    ctx.arc(player.x, player.y, player.radius, 0, Math.PI*2);
    ctx.fill();

    // If shield active, draw shield ring
    if(player.powerups.shield > 0) {
      ctx.strokeStyle = '#ff0';
      ctx.lineWidth = 4;
      ctx.beginPath();
      ctx.arc(player.x, player.y, player.radius + 6, 0, Math.PI*2);
      ctx.stroke();
    }

    // Bullets
    for(let b of bullets) {
      ctx.fillStyle = b.color;
      ctx.beginPath();
      ctx.arc(b.x, b.y, b.radius, 0, Math.PI*2);
      ctx.fill();
    }

    // Enemies
    for(let e of enemies) {
      ctx.fillStyle = e.color;
      ctx.beginPath();
      ctx.arc(e.x, e.y, e.radius, 0, Math.PI*2);
      ctx.fill();
      // Eye effect
      ctx.fillStyle = 'white';
      ctx.beginPath();
      ctx.arc(e.x - e.radius/3, e.y - e.radius/3, e.radius/5, 0, Math.PI*2);
      ctx.arc(e.x + e.radius/3, e.y - e.radius/3, e.radius/5, 0, Math.PI*2);
      ctx.fill();
      ctx.fillStyle = 'black';
      ctx.beginPath();
      ctx.arc(e.x - e.radius/3, e.y - e.radius/3, e.radius/10, 0, Math.PI*2);
      ctx.arc(e.x + e.radius/3, e.y - e.radius/3, e.radius/10, 0, Math.PI*2);
      ctx.fill();
    }

    // Powerups
    for(let p of powerups){
      p.draw(ctx);
    }

    // Particles
    for(let p of particles){
      p.draw(ctx);
    }
  }

  function updateScore() {
    document.getElementById('score').innerText = `Score: ${score}`;
  }
  function updateHealthBar() {
    const healthPercent = (player.health / player.maxHealth) * 100;
    document.getElementById('health-bar-inner').style.width = healthPercent + '%';
    // Change health bar color (green -> red)
    const green = Math.floor(healthPercent * 2.55);
    const red = 255 - green;
    document.getElementById('health-bar-inner').style.backgroundColor = `rgb(${red},${green},0)`;
  }
  function updateTimer() {
    const elapsedSeconds = Math.floor((Date.now() - startTime) / 1000);
    document.getElementById('timer').innerText = `Time: ${elapsedSeconds}s`;
  }

  function drawGameOver() {
    ctx.fillStyle = 'rgba(0,0,0,0.8)';
    ctx.fillRect(0, 0, W, H);
    ctx.fillStyle = 'red';
    ctx.font = '72px monospace';
    ctx.textAlign = 'center';
    ctx.fillText('GAME OVER', W/2, H/2);
    ctx.font = '36px monospace';
    ctx.fillText(`Final Score: ${score}`, W/2, H/2 + 60);
    ctx.fillText(`Time Survived: ${Math.floor((Date.now() - startTime)/1000)}s`, W/2, H/2 + 110);
    ctx.fillText('Refresh to play again!', W/2, H/2 + 160);
  }

  updateScore();
  updateHealthBar();
  updateTimer();
  gameLoop();

})();
</script>
</body>
</html>
