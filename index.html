<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>Enhanced 2D Shooter Game</title>
<style>
  html, body {
    margin: 0; padding: 0; overflow: hidden;
    background: radial-gradient(circle at center, #001100, #000000);
    font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
    color: white;
    user-select: none;
  }
  canvas {
    display: block;
    background: #002200;
    margin: 0 auto;
    box-shadow: 0 0 20px #0f0;
  }
  #menu-overlay {
    position: fixed; top: 0; left: 0; width: 100vw; height: 100vh;
    background: rgba(0, 0, 0, 0.85);
    display: flex; flex-direction: column; justify-content: center; align-items: center;
    z-index: 10;
  }
  button {
    background: linear-gradient(45deg, #0a0, #0f0);
    border: none; border-radius: 8px;
    padding: 15px 30px;
    font-size: 1.4rem;
    color: white;
    cursor: pointer;
    box-shadow: 0 0 10px #0f0;
    transition: background 0.3s ease;
    margin: 10px;
  }
  button:hover {
    background: linear-gradient(45deg, #0f0, #0a0);
  }
  #upgrade-panel {
    position: fixed; bottom: 15px; right: 15px;
    background: rgba(0, 50, 0, 0.85);
    border-radius: 10px;
    padding: 10px;
    max-width: 300px;
    display: none;
    z-index: 11;
    box-shadow: 0 0 15px #0f0;
  }
  #upgrade-panel h2 {
    margin-top: 0; margin-bottom: 10px; font-weight: 700;
  }
  #upgrade-panel button {
    width: 100%;
    margin-bottom: 8px;
    font-weight: 600;
  }
  #ui-bar {
    position: fixed; top: 8px; left: 8px;
    color: #0f0;
    text-shadow: 0 0 5px #0f0;
    font-weight: 600;
    user-select: none;
    z-index: 9;
  }
  #health-bar {
    width: 200px;
    height: 22px;
    background: #111;
    border-radius: 12px;
    overflow: hidden;
    margin-bottom: 8px;
    box-shadow: 0 0 10px #0f0 inset;
  }
  #health-bar-inner {
    height: 100%;
    width: 100%;
    background: linear-gradient(90deg, #0f0, #060);
    transition: width 0.25s ease;
  }
  #ammo-display, #powerup-timers, #score, #timer {
    margin-bottom: 5px;
  }
  #sound-toggle, #pause-btn {
    position: fixed; top: 10px; right: 10px;
    background: rgba(0, 100, 0, 0.7);
    border-radius: 8px;
    padding: 8px 15px;
    font-size: 1rem;
    box-shadow: 0 0 10px #0f0;
    cursor: pointer;
    user-select: none;
    color: white;
    border: none;
  }
  #pause-btn {
    top: 50px;
  }
</style>
</head>
<body>
  <canvas id="game-canvas"></canvas>

  <div id="menu-overlay">
    <button id="start-btn">â–¶ Start Game</button>
  </div>

  <button id="sound-toggle">ðŸ”Š On</button>
  <button id="pause-btn">Pause</button>

  <div id="ui-bar">
    <div id="health-bar"><div id="health-bar-inner"></div></div>
    <div id="ammo-display">Ammo: âˆž</div>
    <div id="powerup-timers"></div>
    <div id="score">Score: 0</div>
    <div id="timer">Time: 0.0s</div>
  </div>

  <div id="upgrade-panel">
    <h2>Upgrades (U)</h2>
    <div>Points: <span id="upgrade-points">0</span></div>
    <button id="upgrade-health">+20 Health (50 pts)</button>
    <button id="upgrade-speed">+1 Speed (50 pts)</button>
    <button id="upgrade-damage">+1 Damage (50 pts)</button>
  </div>

<script>
(() => {
  const canvas = document.getElementById('game-canvas');
  const ctx = canvas.getContext('2d');
  let W = window.innerWidth;
  let H = window.innerHeight;
  canvas.width = W;
  canvas.height = H;

  // Util
  function randRange(min, max) { return Math.random() * (max - min) + min; }
  function clamp(val, min, max) { return Math.min(Math.max(val, min), max); }

  // Game variables
  let keys = {};
  let mouse = {x: 0, y: 0, down: false};
  let gameOver = false;
  let paused = false;
  let lastFrameTime = 0;
  let elapsedTime = 0;
  let score = 0;
  let upgradePoints = 0;

  // UI elements
  const healthBarInner = document.getElementById('health-bar-inner');
  const ammoDisplay = document.getElementById('ammo-display');
  const powerupTimersDisplay = document.getElementById('powerup-timers');
  const scoreDisplay = document.getElementById('score');
  const timerDisplay = document.getElementById('timer');
  const upgradePointsDisplay = document.getElementById('upgrade-points');
  const upgradePanel = document.getElementById('upgrade-panel');
  const startBtn = document.getElementById('start-btn');
  const menuOverlay = document.getElementById('menu-overlay');
  const soundToggleBtn = document.getElementById('sound-toggle');
  const pauseBtn = document.getElementById('pause-btn');

  // Sounds (placeholders - muted by default)
  let soundOn = true;
  const sounds = {
    shoot: new Audio('https://freesound.org/data/previews/320/320181_5260877-lq.mp3'),
    explosion: new Audio('https://freesound.org/data/previews/235/235968_3985816-lq.mp3'),
    damage: new Audio('https://freesound.org/data/previews/401/401703_5121236-lq.mp3'),
    powerup: new Audio('https://freesound.org/data/previews/331/331912_3248244-lq.mp3'),
    bossRoar: new Audio('https://freesound.org/data/previews/201/201918_2859973-lq.mp3')
  };
  for (const s of Object.values(sounds)) {
    s.volume = 0.15;
  }

  // Player
  const player = {
    x: W / 2,
    y: H / 2,
    radius: 20,
    color1: '#0f0',
    color2: '#050',
    vx: 0,
    vy: 0,
    baseSpeed: 6,
    health: 100,
    maxHealth: 100,
    damageBonus: 0,
    upgrades: {health: 0, speed: 0, damage: 0}
  };

  // Weapons
  const weapons = {
    pistol: {name: 'Pistol', ammoMax: Infinity, ammo: Infinity, fireRate: 300, damage: 3, bulletSpeed: 15, radius: 5, color1: '#0f0', color2: '#080'},
    rifle: {name: 'Rifle', ammoMax: 40, ammo: 40, fireRate: 120, damage: 8, bulletSpeed: 20, radius: 5, color1: '#0a0', color2: '#060'},
    smg: {name: 'SMG', ammoMax: 70, ammo: 70, fireRate: 70, damage: 4, bulletSpeed: 18, radius: 4, color1: '#0c0', color2: '#070'},
    sniper: {name: 'Sniper', ammoMax: 10, ammo: 10, fireRate: 600, damage: 20, bulletSpeed: 25, radius: 6, color1: '#0f6', color2: '#093'},
    grenade: {name: 'Grenade', ammoMax: 5, ammo: 5, fireRate: 900, damage: 40, radius: 8, fuse: 90, color1: '#f90', color2: '#d60'}
  };

  let currentWeaponKey = 'pistol';
  let shootCooldown = 0;

  // Entities
  const bullets = [];
  const grenades = [];
  const enemies = [];
  const enemyBullets = [];
  const particles = [];
  const powerups = [];

  // Powerups management
  const activePowerups = {
    speedBoost: 0,
    shield: 0,
    doubleDamage: 0,
    rapidFire: 0,
    invisibility: 0
  };

  // Spawn timers
  let lastEnemySpawn = 0;
  let enemySpawnInterval = 1500;
  let lastPowerupSpawn = 0;
  let powerupSpawnInterval = 8000;

  // Screen shake
  let shakeDuration = 0;
  const shakeMagnitude = 10;
  let bossSpawned = false;

  // --- Utility functions ---
  function playSound(name) {
    if(!soundOn) return;
    const snd = sounds[name];
    if(snd) {
      snd.currentTime = 0;
      snd.play();
    }
  }

  function randColor() {
    const colors = ['#0f0', '#ff0', '#0ff', '#f0f', '#f80'];
    return colors[Math.floor(Math.random()*colors.length)];
  }

  // --- Powerup activation ---
  function activatePowerup(type) {
    activePowerups[type] = performance.now() + 10000;
    playSound('powerup');
  }

  // --- Spawn powerup ---
  function spawnPowerup(x, y) {
    if(Math.random() > 0.6) return;
    const types = ['speedBoost', 'shield', 'doubleDamage', 'rapidFire', 'invisibility'];
    const type = types[Math.floor(Math.random() * types.length)];
    powerups.push(new Powerup(x, y, type));
  }

  // --- Classes ---
  class Bullet {
    constructor(x, y, vx, vy, damage, radius, color1, color2) {
      this.x = x;
      this.y = y;
      this.vx = vx;
      this.vy = vy;
      this.damage = damage;
      this.radius = radius;
      this.color1 = color1;
      this.color2 = color2;
      this.trail = [];
    }
    update() {
      this.x += this.vx;
      this.y += this.vy;

      this.trail.push({x: this.x, y: this.y});
      if(this.trail.length > 6) this.trail.shift();

      // Remove if off screen
      if(this.x < -50 || this.x > W+50 || this.y < -50 || this.y > H+50) {
        bullets.splice(bullets.indexOf(this), 1);
      }
    }
    draw() {
      // Trail
      ctx.beginPath();
      for(let i = 0; i < this.trail.length - 1; i++) {
        const p1 = this.trail[i];
        const p2 = this.trail[i+1];
        ctx.strokeStyle = `rgba(0,255,0,${i/this.trail.length*0.3})`;
        ctx.lineWidth = 2;
        ctx.moveTo(p1.x, p1.y);
        ctx.lineTo(p2.x, p2.y);
        ctx.stroke();
      }

      // Bullet body with gradient
      let grad = ctx.createRadialGradient(this.x, this.y, this.radius*0.1, this.x, this.y, this.radius);
      grad.addColorStop(0, this.color1);
      grad.addColorStop(1, this.color2);
      ctx.fillStyle = grad;
      ctx.beginPath();
      ctx.shadowColor = this.color1;
      ctx.shadowBlur = 10;
      ctx.arc(this.x, this.y, this.radius, 0, Math.PI*2);
      ctx.fill();
      ctx.shadowBlur = 0;
    }
  }

  class Grenade {
    constructor(x, y, vx, vy, damage, fuse) {
      this.x = x;
      this.y = y;
      this.vx = vx;
      this.vy = vy;
      this.damage = damage;
      this.radius = 10;
      this.fuse = fuse || 90; // frames
      this.life = this.fuse;
      this.exploded = false;
      this.color1 = '#f90';
      this.color2 = '#d60';
      this.bounceDamping = 0.6;
    }
    update() {
      if(this.exploded) return;
      this.vy += 0.3; // gravity
      this.x += this.vx;
      this.y += this.vy;

      if(this.y > H - this.radius) {
        this.y = H - this.radius;
        this.vy *= -this.bounceDamping;
        this.vx *= 0.7;
      }

      this.life--;
      if(this.life <= 0) this.explode();
    }
    explode() {
      this.exploded = true;
      playSound('explosion');
      // Explosion particles
      for(let i=0; i<30; i++) {
        particles.push(new Particle(this.x, this.y, randRange(-6,6), randRange(-6,6), '#f90', 30));
      }
      // Damage enemies close by
      enemies.forEach(e => {
        let dx = e.x - this.x;
        let dy = e.y - this.y;
        let dist = Math.sqrt(dx*dx + dy*dy);
        if(dist < 80) {
          e.health -= this.damage * (1 - dist/80);
        }
      });
      // Remove grenade
      grenades.splice(grenades.indexOf(this), 1);
    }
    draw() {
      if(this.exploded) return;
      let grad = ctx.createRadialGradient(this.x, this.y, this.radius*0.3, this.x, this.y, this.radius);
      grad.addColorStop(0, this.color1);
      grad.addColorStop(1, this.color2);
      ctx.fillStyle = grad;
      ctx.shadowColor = this.color1;
      ctx.shadowBlur = 15;
      ctx.beginPath();
      ctx.arc(this.x, this.y, this.radius, 0, Math.PI*2);
      ctx.fill();
      ctx.shadowBlur = 0;
    }
  }

  class Particle {
    constructor(x, y, vx, vy, color, life) {
      this.x = x;
      this.y = y;
      this.vx = vx;
      this.vy = vy;
      this.color = color;
      this.life = life;
      this.radius = 3;
    }
    update() {
      this.x += this.vx;
      this.y += this.vy;
      this.vx *= 0.95;
      this.vy *= 0.95;
      this.life--;
      this.radius *= 0.92;
    }
    draw() {
      ctx.beginPath();
      ctx.fillStyle = this.color;
      ctx.globalAlpha = Math.max(this.life / 30, 0);
      ctx.arc(this.x, this.y, this.radius, 0, Math.PI*2);
      ctx.fill();
      ctx.globalAlpha = 1;
    }
  }

  class Enemy {
    constructor(type = 'basic') {
      this.type = type;
      this.x = Math.random() < 0.5 ? -30 : W + 30;
      this.y = randRange(50, H - 50);
      this.radius = 18;
      this.color1 = '#a00';
      this.color2 = '#400';
      this.speed = randRange(1.5, 3);
      this.health = 10;
      this.damage = 10;
      this.shootCooldown = 0;
      this.splitOnDeath = false;
      this.isBoss = false;

      switch(type) {
        case 'ranged':
          this.color1 = '#f84';
          this.color2 = '#a50';
          this.speed = 1.6;
          this.health = 12;
          this.shootCooldown = 80;
          this.damage = 7;
          break;
        case 'splitter':
          this.color1 = '#fa0';
          this.color2 = '#a70';
          this.speed = 2.3;
          this.health = 8;
          this.splitOnDeath = true;
          break;
        case 'flame':
          this.color1 = '#f44';
          this.color2 = '#a33';
          this.speed = 2.7;
          this.health = 15;
          this.damage = 15;
          break;
        case 'shieldedBoss':
          this.color1 = '#08f';
          this.color2 = '#05a';
          this.speed = 1;
          this.health = 120;
          this.damage = 25;
          this.isBoss = true;
          this.shield = 50;
          break;
      }

      this.vx = this.x < W/2 ? this.speed : -this.speed;
      this.vy = 0;
    }

    update() {
      // Move toward player
      const dx = player.x - this.x;
      const dy = player.y - this.y;
      const dist = Math.sqrt(dx*dx + dy*dy);
      if(dist > 5) {
        this.vx = (dx / dist) * this.speed;
        this.vy = (dy / dist) * this.speed;
      } else {
        this.vx = 0; this.vy = 0;
      }

      this.x += this.vx;
      this.y += this.vy;

      if(this.type === 'ranged' && this.shootCooldown <= 0) {
        // Shoot toward player
        const angle = Math.atan2(dy, dx);
        enemyBullets.push(new EnemyBullet(this.x, this.y, Math.cos(angle)*8, Math.sin(angle)*8, this.damage));
        this.shootCooldown = 90;
        playSound('shoot');
      }
      this.shootCooldown = Math.max(this.shootCooldown - 1, 0);

      if(this.health <= 0) {
        if(this.splitOnDeath) {
          for(let i=0; i<2; i++) {
            enemies.push(new Enemy('basic'));
          }
        }
        // Boss death logic here (simplified)
        if(this.isBoss) {
          playSound('bossRoar');
          upgradePoints += 20; // Boss rewards points
        } else {
          upgradePoints++;
        }
        score += 10;
        particles.push(new Particle(this.x, this.y, 0, 0, '#f00', 40));
        enemies.splice(enemies.indexOf(this), 1);
      }
    }

    draw() {
      let grad = ctx.createRadialGradient(this.x, this.y, this.radius*0.4, this.x, this.y, this.radius);
      grad.addColorStop(0, this.color1);
      grad.addColorStop(1, this.color2);
      ctx.fillStyle = grad;
      ctx.shadowColor = this.color1;
      ctx.shadowBlur = 15;
      ctx.beginPath();
      ctx.arc(this.x, this.y, this.radius, 0, Math.PI*2);
      ctx.fill();
      ctx.shadowBlur = 0;

      if(this.isBoss) {
        // Draw shield bar
        ctx.strokeStyle = '#0ff';
        ctx.lineWidth = 4;
        ctx.beginPath();
        ctx.arc(this.x, this.y, this.radius+6, 0, (this.shield / 50) * Math.PI * 2);
        ctx.stroke();
      }
    }
  }

  class EnemyBullet {
    constructor(x, y, vx, vy, damage) {
      this.x = x;
      this.y = y;
      this.vx = vx;
      this.vy = vy;
      this.damage = damage;
      this.radius = 6;
      this.color1 = '#f00';
      this.color2 = '#a00';
      this.life = 180;
    }
    update() {
      this.x += this.vx;
      this.y += this.vy;
      this.life--;
      if(this.life <= 0) enemyBullets.splice(enemyBullets.indexOf(this), 1);
    }
    draw() {
      let grad = ctx.createRadialGradient(this.x, this.y, this.radius*0.3, this.x, this.y, this.radius);
      grad.addColorStop(0, this.color1);
      grad.addColorStop(1, this.color2);
      ctx.fillStyle = grad;
      ctx.shadowColor = this.color1;
      ctx.shadowBlur = 12;
      ctx.beginPath();
      ctx.arc(this.x, this.y, this.radius, 0, Math.PI*2);
      ctx.fill();
      ctx.shadowBlur = 0;
    }
  }

  class Powerup {
    constructor(x, y, type) {
      this.x = x;
      this.y = y;
      this.type = type;
      this.radius = 15;
      this.color = '#0f0';
      this.pulse = 0;
      switch(type) {
        case 'speedBoost': this.color = '#0ff'; break;
        case 'shield': this.color = '#08f'; break;
        case 'doubleDamage': this.color = '#ff0'; break;
        case 'rapidFire': this.color = '#f0f'; break;
        case 'invisibility': this.color = '#f80'; break;
      }
    }
    update() {
      this.pulse += 0.1;
      // Check collision with player
      const dx = player.x - this.x;
      const dy = player.y - this.y;
      if(Math.sqrt(dx*dx + dy*dy) < player.radius + this.radius) {
        activatePowerup(this.type);
        powerups.splice(powerups.indexOf(this), 1);
      }
    }
    draw() {
      const pulseScale = 1 + Math.sin(this.pulse) * 0.15;
      ctx.fillStyle = this.color;
      ctx.shadowColor = this.color;
      ctx.shadowBlur = 20;
      ctx.beginPath();
      ctx.arc(this.x, this.y, this.radius * pulseScale, 0, Math.PI*2);
      ctx.fill();
      ctx.shadowBlur = 0;
    }
  }

  // --- Player methods ---
  function updatePlayer() {
    // Movement
    let speed = player.baseSpeed + (activePowerups.speedBoost > performance.now() ? 4 : 0) + player.upgrades.speed;
    player.vx = 0; player.vy = 0;

    if(keys['ArrowLeft'] || keys['a']) player.vx = -speed;
    if(keys['ArrowRight'] || keys['d']) player.vx = speed;
    if(keys['ArrowUp'] || keys['w']) player.vy = -speed;
    if(keys['ArrowDown'] || keys['s']) player.vy = speed;

    // Normalize diagonal speed
    if(player.vx !== 0 && player.vy !== 0) {
      player.vx *= 0.707;
      player.vy *= 0.707;
    }

    player.x = clamp(player.x + player.vx, player.radius, W - player.radius);
    player.y = clamp(player.y + player.vy, player.radius, H - player.radius);

    // Collision with enemy bullets
    for(let i = enemyBullets.length - 1; i >= 0; i--) {
      const b = enemyBullets[i];
      let dx = b.x - player.x;
      let dy = b.y - player.y;
      let dist = Math.sqrt(dx*dx + dy*dy);
      if(dist < b.radius + player.radius) {
        if(activePowerups.shield < performance.now()) {
          player.health -= b.damage;
          playSound('damage');
          shakeDuration = 15;
          if(player.health <= 0) endGame();
        }
        enemyBullets.splice(i, 1);
      }
    }

    // Collision with enemies
    for(let i = enemies.length -1; i >= 0; i--) {
      const e = enemies[i];
      let dx = e.x - player.x;
      let dy = e.y - player.y;
      let dist = Math.sqrt(dx*dx + dy*dy);
      if(dist < e.radius + player.radius) {
        if(activePowerups.shield < performance.now()) {
          player.health -= e.damage * 0.3;
          playSound('damage');
          shakeDuration = 15;
          if(player.health <= 0) endGame();
        }
      }
    }
    updateHealthBar();
  }

  function drawPlayer() {
    // Glow circle
    ctx.shadowColor = '#0f0';
    ctx.shadowBlur = 20;
    let grad = ctx.createRadialGradient(player.x, player.y, player.radius*0.2, player.x, player.y, player.radius);
    grad.addColorStop(0, '#0f0');
    grad.addColorStop(1, '#060');
    ctx.fillStyle = grad;
    ctx.beginPath();
    ctx.arc(player.x, player.y, player.radius, 0, Math.PI*2);
    ctx.fill();
    ctx.shadowBlur = 0;

    // Weapon direction indicator (simple triangle)
    const angle = Math.atan2(mouse.y - player.y, mouse.x - player.x);
    ctx.fillStyle = '#0a0';
    ctx.beginPath();
    ctx.moveTo(player.x + Math.cos(angle) * player.radius * 1.1, player.y + Math.sin(angle) * player.radius * 1.1);
    ctx.lineTo(player.x + Math.cos(angle + 0.5) * player.radius * 0.6, player.y + Math.sin(angle + 0.5) * player.radius * 0.6);
    ctx.lineTo(player.x + Math.cos(angle - 0.5) * player.radius * 0.6, player.y + Math.sin(angle - 0.5) * player.radius * 0.6);
    ctx.closePath();
    ctx.fill();
  }

  // --- Shooting ---
  function shoot() {
    if(gameOver || paused) return;
    if(shootCooldown > 0) return;

    const weapon = weapons[currentWeaponKey];
    if(weapon.ammo === 0) return;

    // Ammo consume
    if(weapon.ammo !== Infinity) weapon.ammo--;

    const angle = Math.atan2(mouse.y - player.y, mouse.x - player.x);
    const bulletSpeed = weapon.bulletSpeed || 0;

    if(currentWeaponKey === 'grenade') {
      // Throw grenade with arc
      const vx = Math.cos(angle) * 10;
      const vy = Math.sin(angle) * 10 - 8;
      grenades.push(new Grenade(player.x + Math.cos(angle)*player.radius, player.y + Math.sin(angle)*player.radius, vx, vy, weapon.damage, weapon.fuse));
    } else {
      // Spawn bullet
      bullets.push(new Bullet(
        player.x + Math.cos(angle) * player.radius,
        player.y + Math.sin(angle) * player.radius,
        Math.cos(angle) * bulletSpeed,
        Math.sin(angle) * bulletSpeed,
        weapon.damage + player.damageBonus + (activePowerups.doubleDamage > performance.now() ? 5 : 0),
        weapon.radius,
        weapon.color1,
        weapon.color2
      ));
    }
    playSound('shoot');
    shootCooldown = weapon.fireRate / (activePowerups.rapidFire > performance.now() ? 2 : 1);
    updateAmmoDisplay();
  }

  // --- Update bullets ---
  function updateBullets() {
    bullets.forEach(b => b.update());
  }
  function drawBullets() {
    bullets.forEach(b => b.draw());
  }

  // --- Update grenades ---
  function updateGrenades() {
    grenades.forEach(g => g.update());
  }
  function drawGrenades() {
    grenades.forEach(g => g.draw());
  }

  // --- Update enemies ---
  function updateEnemies() {
    enemies.forEach(e => e.update());
  }
  function drawEnemies() {
    enemies.forEach(e => e.draw());
  }

  // --- Update enemy bullets ---
  function updateEnemyBullets() {
    enemyBullets.forEach(b => b.update());
  }
  function drawEnemyBullets() {
    enemyBullets.forEach(b => b.draw());
  }

  // --- Update particles ---
  function updateParticles() {
    for(let i = particles.length - 1; i >= 0; i--) {
      particles[i].update();
      if(particles[i].life <= 0 || particles[i].radius <= 0.5) particles.splice(i, 1);
    }
  }
  function drawParticles() {
    particles.forEach(p => p.draw());
  }

  // --- Update powerups ---
  function updatePowerups() {
    powerups.forEach(p => p.update());
  }
  function drawPowerups() {
    powerups.forEach(p => p.draw());
  }

  // --- Screen shake ---
  function applyScreenShake() {
    if(shakeDuration > 0) {
      const dx = (Math.random() - 0.5) * shakeMagnitude;
      const dy = (Math.random() - 0.5) * shakeMagnitude;
      ctx.translate(dx, dy);
      shakeDuration--;
    }
  }

  // --- Spawn enemy ---
  function spawnEnemy() {
    if(gameOver || paused) return;
    let enemyTypes = ['basic', 'ranged', 'splitter', 'flame'];
    let type = enemyTypes[Math.floor(Math.random() * enemyTypes.length)];
    enemies.push(new Enemy(type));
  }

  // --- Spawn boss ---
  function spawnBoss() {
    if(bossSpawned) return;
    enemies.push(new Enemy('shieldedBoss'));
    bossSpawned = true;
    playSound('bossRoar');
  }

  // --- Spawn powerups periodically ---
  function spawnPowerupsOverTime() {
    if(performance.now() - lastPowerupSpawn > powerupSpawnInterval) {
      const x = randRange(50, W-50);
      const y = randRange(50, H-50);
      spawnPowerup(x, y);
      lastPowerupSpawn = performance.now();
    }
  }

  // --- Update UI ---
  function updateHealthBar() {
    const perc = clamp(player.health / player.maxHealth, 0, 1);
    healthBarInner.style.width = `${perc * 100}%`;
  }
  function updateAmmoDisplay() {
    const ammo = weapons[currentWeaponKey].ammo;
    ammoDisplay.textContent = `Ammo: ${ammo === Infinity ? 'âˆž' : ammo}`;
  }
  function updatePowerupTimersDisplay() {
    const now = performance.now();
    let texts = [];
    for(const [key, time] of Object.entries(activePowerups)) {
      if(time > now) {
        let sec = ((time - now)/1000).toFixed(1);
        const names = {
          speedBoost: 'Speed',
          shield: 'Shield',
          doubleDamage: '2x Damage',
          rapidFire: 'Rapid Fire',
          invisibility: 'Invisibility'
        };
        texts.push(`${names[key]}: ${sec}s`);
      }
    }
    powerupTimersDisplay.textContent = texts.join(' | ');
  }
  function updateScoreDisplay() {
    scoreDisplay.textContent = `Score: ${score}`;
  }
  function updateTimerDisplay() {
    timerDisplay.textContent = `Time: ${(elapsedTime/1000).toFixed(1)}s`;
  }
  function updateUpgradePointsDisplay() {
    upgradePointsDisplay.textContent = upgradePoints;
  }

  // --- End game ---
  function endGame() {
    gameOver = true;
    paused = true;
    menuOverlay.style.display = 'flex';
    startBtn.textContent = 'Restart Game';
  }

  // --- Restart game ---
  function restartGame() {
    gameOver = false;
    paused = false;
    score = 0;
    upgradePoints = 0;
    elapsedTime = 0;
    player.x = W/2;
    player.y = H/2;
    player.health = player.maxHealth = 100 + (player.upgrades.health * 20);
    player.baseSpeed = 6 + player.upgrades.speed;
    player.damageBonus = player.upgrades.damage;
    bullets.length = 0;
    grenades.length = 0;
    enemies.length = 0;
    enemyBullets.length = 0;
    particles.length = 0;
    powerups.length = 0;
    shootCooldown = 0;
    lastEnemySpawn = performance.now();
    lastPowerupSpawn = performance.now();
    shakeDuration = 0;
    bossSpawned = false;
    menuOverlay.style.display = 'none';
    updateHealthBar();
    updateAmmoDisplay();
    updateUpgradePointsDisplay();
  }

  // --- Upgrade buttons ---
  const upgradeHealthBtn = document.getElementById('upgrade-health');
  const upgradeSpeedBtn = document.getElementById('upgrade-speed');
  const upgradeDamageBtn = document.getElementById('upgrade-damage');

  upgradeHealthBtn.onclick = () => {
    if(upgradePoints >= 50) {
      upgradePoints -= 50;
      player.upgrades.health++;
      player.maxHealth += 20;
      player.health = player.maxHealth;
      updateUpgradePointsDisplay();
      updateHealthBar();
    }
  };
  upgradeSpeedBtn.onclick = () => {
    if(upgradePoints >= 50) {
      upgradePoints -= 50;
      player.upgrades.speed++;
      player.baseSpeed = 6 + player.upgrades.speed;
      updateUpgradePointsDisplay();
    }
  };
  upgradeDamageBtn.onclick = () => {
    if(upgradePoints >= 50) {
      upgradePoints -= 50;
      player.upgrades.damage++;
      player.damageBonus = player.upgrades.damage;
      updateUpgradePointsDisplay();
    }
  };

  // --- Input handlers ---
  window.addEventListener('keydown', e => {
    keys[e.key.toLowerCase()] = true;
    if(e.key === 'p' || e.key === 'P') {
      paused = !paused;
      pauseBtn.textContent = paused ? 'Resume' : 'Pause';
      if(!paused) lastFrameTime = performance.now();
      menuOverlay.style.display = paused && gameOver ? 'flex' : 'none';
    }
    if(e.key === 'u' || e.key === 'U') {
      if(upgradePanel.style.display === 'none') {
        upgradePanel.style.display = 'block';
      } else {
        upgradePanel.style.display = 'none';
      }
    }
    // Weapon switching 1-5
    if(['1','2','3','4','5'].includes(e.key)) {
      const keysMap = {1:'pistol', 2:'rifle', 3:'smg', 4:'sniper', 5:'grenade'};
      currentWeaponKey = keysMap[e.key];
      updateAmmoDisplay();
    }
  });
  window.addEventListener('keyup', e => {
    keys[e.key.toLowerCase()] = false;
  });

  canvas.addEventListener('mousemove', e => {
    const rect = canvas.getBoundingClientRect();
    mouse.x = e.clientX - rect.left;
    mouse.y = e.clientY - rect.top;
  });
  canvas.addEventListener('mousedown', e => {
    mouse.down = true;
  });
  window.addEventListener('mouseup', e => {
    mouse.down = false;
  });

  // --- Game loop ---
  function update(delta) {
    if(gameOver || paused) return;
    elapsedTime += delta;

    shootCooldown = Math.max(0, shootCooldown - delta);

    if(mouse.down) {
      shoot();
    }

    updatePlayer();
    updateBullets();
    updateGrenades();
    updateEnemies();
    updateEnemyBullets();
    updateParticles();
    updatePowerups();
    spawnPowerupsOverTime();

    // Spawn enemies over time (increasing difficulty)
    if(performance.now() - lastEnemySpawn > enemySpawnInterval) {
      spawnEnemy();
      lastEnemySpawn = performance.now();
      if(enemySpawnInterval > 400) enemySpawnInterval -= 10;
      if(score > 150 && !bossSpawned) spawnBoss();
    }

    updateAmmoDisplay();
    updatePowerupTimersDisplay();
    updateScoreDisplay();
    updateTimerDisplay();
  }

  function drawBackground() {
    // Dark gradient already set by CSS, add some particles/stars
    for(let i = 0; i < 60; i++) {
      ctx.fillStyle = 'rgba(0,255,0,0.05)';
      const x = Math.random()*W;
      const y = Math.random()*H;
      ctx.beginPath();
      ctx.arc(x, y, 1.5, 0, Math.PI*2);
      ctx.fill();
    }
  }

  function draw() {
    ctx.clearRect(0, 0, W, H);
    drawBackground();

    ctx.save();
    applyScreenShake();

    drawPowerups();
    drawBullets();
    drawGrenades();
    drawEnemies();
    drawEnemyBullets();
    drawParticles();
    drawPlayer();

    ctx.restore();
  }

  function loop(timestamp) {
    if(!lastFrameTime) lastFrameTime = timestamp;
    const delta = timestamp - lastFrameTime;
    lastFrameTime = timestamp;
    update(delta);
    draw();
    requestAnimationFrame(loop);
  }

  // --- UI button events ---
  startBtn.onclick = () => {
    restartGame();
  };

  soundToggleBtn.onclick = () => {
    soundOn = !soundOn;
    soundToggleBtn.textContent = soundOn ? 'ðŸ”Š On' : 'ðŸ”‡ Off';
  };

  pauseBtn.onclick = () => {
    paused = !paused;
    pauseBtn.textContent = paused ? 'Resume' : 'Pause';
    if(!paused) lastFrameTime = performance.now();
  };

  // --- Resize ---
  window.addEventListener('resize', () => {
    W = window.innerWidth;
    H = window.innerHeight;
    canvas.width = W;
    canvas.height = H;
  });

  // Start animation loop
  requestAnimationFrame(loop);
})();
</script>
</body>
</html>
